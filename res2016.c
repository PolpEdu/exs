/*
    Implemente um simulador de uma estação de notícias com várias equipas de reportagem espalhadas pelo
    mundo. Cada uma das equipas envia periodicamente as notícias para a central. Na central, existe um editor
    que revê as notícias por ordem de chegada e decide quais devem ser publicadas.
    Na sua solução, represente cada uma das equipas de reportagem como um processo (devem existir 10
    equipas). Cada equipa deverá comunicar com o processo principal através de um pipe (i.e. haverá tantos
    pipes como equipas de reportagem). Cada equipa deve enviar uma notícia a cada 1-3 segundos.
    O processo principal será o editor. Deverá ficar encarregue de monitorar todos os pipes em simultâneo, ler as
    notícias recebidas e aceitar apenas 10%, imprimindo-as para a consola.
    Após receber Ctrl+C o programa deverá terminar eliminando todos os recursos. Esta opção só estará
    disponível após todos os processos criados. O processo principal apenas deverá terminar após todos os
    processos filho terminarem.

    NewsTeam 0 Submitting news: "home team wins"
    NewsTeam 5 Submitting news: "food for the soul"
    NEWS FLASH: team [1]: home team wins
    NewsTeam 4 Submitting news: "an amazing discovery"
    ^C pressed. Shutting down news team 2...
    ^C pressed. Shutting down news team 4...
    ^C pressed. Editor shutting down...
*/

// include signint
#include <signal.h>

// include fdset
#include <sys/select.h>

#define N_NEWSTEAMS 10
#define EXAMPLE_NEWS 5
#define NEWS_MAX_SIZE 512

int main_pid;
int pipes[N_NEWSTEAMS][2];
// Just some news used as an example
char example_news[EXAMPLE_NEWS][NEWS_MAX_SIZE] = {
    "all about the money",
    "food for the soul",
    "home team wins",
    "an amazing discovery",
    "newest tec came out"};

// News structure that will be used to send news through the pipes
typedef struct _news
{
    int team;
    char newsText[NEWS_MAX_SIZE];
} news;
news news_data;
// Treatment of signal generated by Ctrl+C
// Editor waits for all the NEWSTEAMS to finish and removes resources (closes all open
// pipes);
// NEWSTEAMS clean used resources (close all open pipes). Each process prints a
// message to the screen (see example output

void sigint(int signum)
{
    // *** COMPLETE ***
    // wait for all the NEWSTEAMS to finish
    int i;
    for (i = 0; i < N_NEWSTEAMS; i++)
    {
        // wait for the NEWSTEAMS to finish
        wait(NULL);
        // close all open pipes
        printf("^C pressed. Shutting down news team %d...\n", i);
        close(pipes[i][0]);
        printf("^C pressed. Shutting down news team %d...\n", i);
        close(pipes[i][1]);
    }

    // close all open pipes
    printf("Editor shutting down...\n");

    // close main process
    kill(main_pid, SIGINT);

    // *** END COMPLETE ***
    exit(0);
}

// Code run by NEWSTEAMS
void newsTeam(int channel[], int i)
{
    news_data.team = i;
    srand(i);
    // *** COMPLETE: Handle CTRL-C ***
    signal(SIGINT, sigint);

    // *** END COMPLETE ***
    while (1)
    {
        // pick a random news content
        strcpy(news_data.newsText, example_news[rand() % EXAMPLE_NEWS]);
        printf("News team %d Submitting news: \"%s\" \n", news_data.team,
               news_data.newsText);

        //*** COMPLETE: Send news to pipe and sleep between 1 to 3 seconds ***
        write(channel[1], &news_data, sizeof(news_data));
        sleep(rand() % 3 + 1);

        // *** END COMPLETE ***
    }
}

int main(int argc, char *argv[])
{
    main_pid = getpid();
    // *** COMPLETE: Ignore CTRL-C ***
    // ignre Ctrl^C: SIG_IGN just ignores.
    signal(SIGINT, SIG_IGN); //#include <signal.h>
    // *** END COMPLETE ***

    // *** COMPLETE: Create NEWSTEAMS (processes and pipes) ***
    int i;
    for (i = 0; i < N_NEWSTEAMS; i++)
    {
        // create pipes
        if (pipe(pipes[i]) == -1)
        {
            printf("Error creating pipe\n");
            exit(1);
        }
        // create NEWSTEAMS
        if (fork() == 0)
        {
            // close unused pipes
            close(pipes[i][0]);
            close(pipes[i][1]);
            // run NEWSTEAMS
            newsTeam(pipes[i], i);
        }
    }
    // *** END COMPLETE ***

    // Editor
    fd_set read_set;
    int r;
    // COMPLETE: Handle CTRL-C
    signal(SIGINT, sigint); // now instead of just ignoring Ctrl^C, it will call sigint
    // *** END COMPLETE ***
    while (1)
    {
        // todo: Read from Pipes, publish only 10%
        FD_ZERO(&read_set); // FD_ZERO: Cleans up the file descriptor set
        for (i = 0; i < N_NEWSTEAMS; i++)
        {
            FD_SET(pipes[i][0], &read_set); // Sets a bit (1) in the file descriptor set for each of the descriptors in the set
        }
        r = select(FD_SETSIZE, &read_set, NULL, NULL, NULL); // select: Waits for one of the specified file descriptors to become ready to perform I/O
        if (r == -1)
        {
            printf("Error reading from pipes\n");
            exit(1);
        }
        else
        { // r is 1
            for (i = 0; i < N_NEWSTEAMS; i++)
            {
                // publish only 10% of the total news
                if (FD_ISSET(pipes[i][0], &read_set) && rand() % 10 == 0) // FD_ISSET: Checks if the file descriptor is set to 1 in the file descriptor set
                {
                    // se no pipe está um 1, leio a notícia desse bit no pipe
                    read(pipes[i][0], &news_data, sizeof(news_data)); // read news from pipe
                    printf("NEWS FLASH: team [%d]: %s\n", news_data.team,
                           news_data.newsText);

                    close(pipes[i][0]);
                }
            }
        }

        // *** END COMPLETE ***
    } // While(1)
    return 0;
}
